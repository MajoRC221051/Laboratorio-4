# -*- coding: utf-8 -*-
"""Laboratorio#4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PShHUXgCLf_yNlabNPSYv-ye2AUgHCHA

# **Laboratorio #4**
Daniel Machic (22118), María José Ramírez (221051)

**Link Github: **https://github.com/MajoRC221051/Laboratorio-4
"""

!pip install openeo
!pip install rasterio

# -*- coding: utf-8 -*-
!pip install geopandas rasterio

import openeo
import rasterio
import numpy as np
import matplotlib.pyplot as plt
from datetime import date
import calendar
import os
import geopandas as gpd

"""### **1. Conexión con la API de Sentinel2**"""

connection = openeo.connect("https://openeo.dataspace.copernicus.eu").authenticate_oidc()

#Areas de interes
lago_atitlan = {
    "west": -91.326256,
"east": -91.07151,
"south": 14.5948,
"north": 14.750979
}
lago_amatitlan = {
    "west": -90.638065,
"east": -90.512924,
"south": 14.412347,
"north": 14.493799
}

"""Cargando las coordeanadas de Guatemala

####  **2) Descargando TIF**

**Atitlan:**
"""

result_graph = atitlan_cube.save_result(format="GTIFF")
job = connection.create_job(result_graph)
job.start_and_wait()
job.download_results("Bandas_Atitlan.tif")

"""**Amatitlan:**"""

result_graph = amatitlan_cube.save_result(format="GTIFF")
job = connection.create_job(result_graph)
job.start_and_wait()
job.download_results("Bandas_Amatitlan.tif")

"""### **3. Seleccionar de Observación:**"""

atitlan_cube = connection.load_collection(
    "SENTINEL2_L2A",
    spatial_extent=lago_atitlan,  # Región de Guatemala
    temporal_extent=["2025-01-01", "2025-06-01"],  # Usa fechas pasadas, no futuras
    bands=["B02","B03","B04", "B08"]
)

amatitlan_cube = connection.load_collection(
    "SENTINEL2_L2A",
    spatial_extent=lago_amatitlan,  # Región de Guatemala
    temporal_extent=["2025-01-01", "2025-06-01"],  # Usa fechas pasadas, no futuras
    bands=["B02","B03","B04", "B08"]
)

"""***Visualización Atitlan:**"""

ruta_tif = "Bandas_Atitlan (1).tif"

with rasterio.open(ruta_tif) as src:
    bandas = src.read()  # Lee todas las bandas
    nombres = src.descriptions if src.descriptions[0] else [f"Banda {i+1}" for i in range(src.count)]
    nodata = src.nodata

# Visualizar bandas individuales
for i in range(bandas.shape[0]):
    plt.figure(figsize=(6, 6))
    img = bandas[i]
    img = np.ma.masked_where(img == nodata, img)
    plt.imshow(img, cmap='gray')
    plt.title(f"{nombres[i]}")
    plt.axis('off')
    plt.colorbar(label="Reflectancia")
    plt.show()

"""**Visualización Amatitlan:**"""

ruta_tif = "Bandas_Amatitlan.tif"

with rasterio.open(ruta_tif) as src:
    bandas = src.read()  # Lee todas las bandas
    nombres = src.descriptions if src.descriptions[0] else [f"Banda {i+1}" for i in range(src.count)]
    nodata = src.nodata

# Visualizar bandas individuales
for i in range(bandas.shape[0]):
    plt.figure(figsize=(6, 6))
    img = bandas[i]
    img = np.ma.masked_where(img == nodata, img)
    plt.imshow(img, cmap='gray')
    plt.title(f"{nombres[i]}")
    plt.axis('off')
    plt.colorbar(label="Reflectancia")
    plt.show()

"""#### **4. Aplica el script de detección de cianobacteria de Sentinel Hub (por ejemplo, Cyano Detection Script) para cada imagen.**"""

import rasterio
import numpy as np
import matplotlib.pyplot as plt

archivo = 'Bandas_Atitlan (1).tif'

with rasterio.open(archivo) as src:
    print(f"Archivo: {archivo}")
    print(f"Número de bandas: {src.count}")
    band_names = src.descriptions if src.descriptions else [f"Band{i+1}" for i in range(src.count)]
    print(f"Band names: {band_names}")

    bands = {}
    for i, band_name in enumerate(band_names):
        band = src.read(i+1).astype(float)
        if band.max() > 1:
            band /= 10000.0
        bands[band_name] = band

B02 = bands.get('B02')
B03 = bands.get('B03')
B04 = bands.get('B04')
B08 = bands.get('B08')

def water_mask_ndwi(green, nir):
    ndwi = (green - nir) / (green + nir + 1e-10)  # pequeño epsilon para evitar div/0
    return (ndwi > 0).astype(np.uint8)

water_mask = water_mask_ndwi(B03, B08)

plt.figure(figsize=(10, 8))
plt.imshow(water_mask, cmap='Blues')
plt.title('Máscara de agua basada en NDWI (B03 y B08)')
plt.axis('off')
plt.colorbar(label='Agua (1) / No agua (0)')
plt.show()

"""Amatitlan"""

import rasterio
import numpy as np
import matplotlib.pyplot as plt

archivo = 'Bandas_Amatitlan.tif'

with rasterio.open(archivo) as src:
    print(f"Archivo: {archivo}")
    print(f"Número de bandas: {src.count}")
    band_names = src.descriptions if src.descriptions else [f"Band{i+1}" for i in range(src.count)]
    print(f"Band names: {band_names}")

    bands = {}
    for i, band_name in enumerate(band_names):
        band = src.read(i+1).astype(float)
        if band.max() > 1:
            band /= 10000.0
        bands[band_name] = band

B02 = bands.get('B02')
B03 = bands.get('B03')
B04 = bands.get('B04')
B08 = bands.get('B08')

def water_mask_ndwi(green, nir):
    ndwi = (green - nir) / (green + nir + 1e-10)  # pequeño epsilon para evitar div/0
    return (ndwi > 0).astype(np.uint8)

water_mask = water_mask_ndwi(B03, B08)

plt.figure(figsize=(10, 8))
plt.imshow(water_mask, cmap='Blues')
plt.title('Máscara de agua basada en NDWI (B03 y B08)')
plt.axis('off')
plt.colorbar(label='Agua (1) / No agua (0)')
plt.show()

"""### **Análisis:**

#### **5. Convertir a arreglos numpy**
"""

import rasterio
import numpy as np
import matplotlib.pyplot as plt

archivo = 'Bandas_Atitlan (1).tif'

with rasterio.open(archivo) as src:
    band_names = src.descriptions if src.descriptions else [f"Band{i+1}" for i in range(src.count)]
    bands = {}
    for i, band_name in enumerate(band_names):
        band = src.read(i+1).astype(float)
        if band.max() > 1:
            band /= 10000.0
        bands[band_name] = band

for name, band in bands.items():
    print(f"Banda: {name}")
    print(f"  Forma: {band.shape}")
    print(f"  Max: {np.nanmax(band):.4f}")
    print(f"  Min: {np.nanmin(band):.4f}")
    print(f"  Media: {np.nanmean(band):.4f}")

green = bands.get('B03')
nir = bands.get('B08')

if green is not None and nir is not None:
    ndwi = (green - nir) / (green + nir + 1e-10)
    print(f"NDWI:")
    print(f"  Max: {np.nanmax(ndwi):.4f}")
    print(f"  Min: {np.nanmin(ndwi):.4f}")
    print(f"  Media: {np.nanmean(ndwi):.4f}")
    plt.figure(figsize=(10, 8))
    plt.imshow(ndwi, cmap='BrBG', vmin=-1, vmax=1)
    plt.colorbar(label='NDWI')
    plt.title('NDWI')
    plt.axis('off')
    plt.show()
else:
    print("No se pudo calcular NDWI: faltan bandas B03 o B08")

import rasterio
import numpy as np
import matplotlib.pyplot as plt

archivo = 'Bandas_Amatitlan.tif'

with rasterio.open(archivo) as src:
    band_names = src.descriptions if src.descriptions else [f"Band{i+1}" for i in range(src.count)]
    bands = {}
    for i, band_name in enumerate(band_names):
        band = src.read(i+1).astype(float)
        if band.max() > 1:
            band /= 10000.0
        bands[band_name] = band

for name, band in bands.items():
    print(f"Banda: {name}")
    print(f"  Forma: {band.shape}")
    print(f"  Max: {np.nanmax(band):.4f}")
    print(f"  Min: {np.nanmin(band):.4f}")
    print(f"  Media: {np.nanmean(band):.4f}")

green = bands.get('B03')
nir = bands.get('B08')

if green is not None and nir is not None:
    ndwi = (green - nir) / (green + nir + 1e-10)
    print(f"NDWI:")
    print(f"  Max: {np.nanmax(ndwi):.4f}")
    print(f"  Min: {np.nanmin(ndwi):.4f}")
    print(f"  Media: {np.nanmean(ndwi):.4f}")
    plt.figure(figsize=(10, 8))
    plt.imshow(ndwi, cmap='BrBG', vmin=-1, vmax=1)
    plt.colorbar(label='NDWI')
    plt.title('NDWI')
    plt.axis('off')
    plt.show()
else:
    print("No se pudo calcular NDWI: faltan bandas B03 o B08")

"""### **Análisis:**

### **6. Análisis temporal**

#### Importando .tif para análisis temporal
"""

from datetime import datetime

# Lista con los primeros días de cada mes (enero a junio)
fechas_mensuales = [
    "2024-07-01",
    "2024-08-01",
    "2024-09-01",
    "2024-10-01",
    "2024-11-01",
    "2024-12-01"
]

for fecha_str in fechas_mensuales:
    print(f"Descargando Atitlán para fecha: {fecha_str}")
    try:
        cube_date = connection.load_collection(
            "SENTINEL2_L2A",
            spatial_extent=lago_atitlan,
            temporal_extent=[fecha_str, fecha_str],
            bands=["B02", "B03", "B04", "B08"]
        )
        result_graph = cube_date.save_result(format="GTIFF")
        job = connection.create_job(result_graph)
        job.start_and_wait()
        output_name = f"Bandas_Atitlan_{fecha_str}.tif"
        job.download_results(output_name)
        print(f"Descargado {output_name}")
    except Exception as e:
        print(f"No se pudo descargar para {fecha_str}: {e}")
        continue

"""##### **6.1 índice promedio de cianobacteria por lago y por fecha.**"""

# --- 1. Conexión a openEO ---
# Esta celda puede que necesite tu autenticación de nuevo si el kernel se reinició
try:
    connection = openeo.connect("https://openeo.dataspace.copernicus.eu").authenticate_oidc()
    print("Conexión con openEO exitosa.")
except Exception as e:
    print(f"Error en la conexión con openEO: {e}")
    raise

# --- 2. Cargar las geometrías exactas desde los archivos GeoJSON ---
# ¡Asegúrate de que los nombres de archivo coincidan con los que subiste!
try:
    amatitlan_gdf = gpd.read_file("Lago_Amatitlan.geojson")
    atitlan_gdf = gpd.read_file("Lago_Atitlan.geojson")

    # Extraer la geometría del GeoDataFrame
    lago_amatitlan_geom = amatitlan_gdf.geometry.iloc[0]
    lago_atitlan_geom = atitlan_gdf.geometry.iloc[0]

    print("Archivos GeoJSON cargados correctamente.")
except Exception as e:
    print(f"ERROR: No se pudieron encontrar o leer los archivos GeoJSON. Asegúrate de que estén subidos a Colab. Detalle: {e}")
    raise

# --- 6.1. Función de cálculo de índice (versión final con GeoJSON) ---
# Esta función no necesita cambios, funciona perfectamente.
def calcular_indice_promedio_lago_final(year, month, geometry, lago_nombre):
    """
    Calcula el NDVI promedio para una geometría y mes específicos usando un
    trabajo asíncrono, enmascarando nubes y recortando al polígono exacto.
    """
    from_date = date(year, month, 1).isoformat()
    last_day = calendar.monthrange(year, month)[1]
    to_date = date(year, month, last_day).isoformat()

    print(f"Creando trabajo para {lago_nombre} de {from_date} a {to_date}...")

    try:
        # Cargar el cubo de datos, usando la GEOMETRÍA exacta como spatial_extent
        cube = connection.load_collection(
            "SENTINEL2_L2A",
            spatial_extent=geometry, # ¡Usamos la geometría del GeoJSON!
            temporal_extent=[from_date, to_date],
            bands=["B03", "B04", "B08", "SCL"]
        )

        # Enmascarar nubes
        scl_band = cube.band("SCL")
        mask = (scl_band == 6) # Solo nos interesan los píxeles que ya están clasificados como AGUA

        cube_masked = cube.mask(mask)

        # Reducir la dimensión temporal a un promedio mensual
        monthly_avg_cube = cube_masked.reduce_dimension(dimension="t", reducer=lambda data, context: data.mean())

        # Crear el trabajo asíncrono
        result_graph = monthly_avg_cube.save_result(format="GTIFF")
        job = connection.create_job(result_graph, title=f"NDVI_{lago_nombre}_{year}-{month}")

        print(f"Trabajo {job.job_id} iniciado. Esperando finalización...")
        job.start_and_wait()
        print(f"Trabajo para {lago_nombre} {year}-{month} completado. Descargando...")

        temp_file = f"temp_image_{lago_nombre}.tif"
        job.download_results(temp_file)

        with rasterio.open(temp_file) as src:
            b03_green = src.read(1).astype(float) / 10000.0
            b04_red = src.read(2).astype(float) / 10000.0
            b08_nir = src.read(3).astype(float) / 10000.0

            nodata_mask = (b03_green == 0)
            b03_green[nodata_mask] = np.nan
            b04_red[nodata_mask] = np.nan
            b08_nir[nodata_mask] = np.nan

            np.seterr(divide='ignore', invalid='ignore')

            ndvi = (b08_nir - b04_red) / (b08_nir + b04_red)

            indice_promedio = np.nanmean(ndvi)

        os.remove(temp_file)

        print(f"Índice promedio para {lago_nombre} {year}-{month:02d}: {indice_promedio:.4f}")
        return indice_promedio

    except Exception as e:
        print(f"Error al procesar el trabajo para {lago_nombre} {year}-{month:02d}: {e}")
        return None

# --- Bucle principal para el análisis temporal (MODIFICADO para Nov 2024 - Abr 2025) ---
# Definimos la lista de tuplas (año, mes) que queremos analizar
periodo_de_interes = [
    (2024, 11), (2024, 12),
    (2025, 1), (2025, 2), (2025, 3), (2025, 4)
]

fechas = []
indices_atitlan = []
indices_amatitlan = []

# Iteramos sobre nuestra lista específica en lugar de un rango de 1 a 12
for year, month in periodo_de_interes:
    fechas.append(date(year, month, 1))

    # Calcular índice para Lago de Atitlán
    indice_ati = calcular_indice_promedio_lago_final(year, month, lago_atitlan_geom, "Atitlan")
    indices_atitlan.append(indice_ati)

    # Calcular índice para Lago de Amatitlán
    indice_ama = calcular_indice_promedio_lago_final(year, month, lago_amatitlan_geom, "Amatitlan")
    indices_amatitlan.append(indice_ama)

# --- 6.2 y 6.3: Visualización y análisis de picos (sin cambios) ---
# El resto del código para graficar y analizar funciona exactamente igual.

print("\nResultados finales Atitlán:", indices_atitlan)
print("Resultados finales Amatitlán:", indices_amatitlan)

plt.style.use('seaborn-v0_8-whitegrid')
fig, ax = plt.subplots(figsize=(14, 7))

# Filtrar resultados nulos para evitar errores en el gráfico
valid_fechas_ati = [fechas[i] for i, v in enumerate(indices_atitlan) if v is not None and np.isfinite(v)]
valid_indices_ati = [v for v in indices_atitlan if v is not None and np.isfinite(v)]
valid_fechas_ama = [fechas[i] for i, v in enumerate(indices_amatitlan) if v is not None and np.isfinite(v)]
valid_indices_ama = [v for v in indices_amatitlan if v is not None and np.isfinite(v)]

ax.plot(valid_fechas_ati, valid_indices_ati, marker='o', linestyle='-', label='Lago de Atitlán')
ax.plot(valid_fechas_ama, valid_indices_ama, marker='s', linestyle='--', label='Lago de Amatitlán')

ax.set_title(f'Evolución del Índice de Cianobacterias (Nov 2024 - Abr 2025)', fontsize=16)
ax.set_xlabel('Fecha', fontsize=12)
ax.set_ylabel('Índice Promedio (NDVI)', fontsize=12)
ax.legend(fontsize=12)
ax.grid(True)

import matplotlib.dates as mdates
ax.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
ax.xaxis.set_major_locator(mdates.MonthLocator())
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Identificación de picos
if valid_indices_ati:
    max_indice_ati = max(valid_indices_ati)
    fecha_pico_ati = valid_fechas_ati[valid_indices_ati.index(max_indice_ati)]
    print(f"\nPico de floración potencial en Atitlán: Mes de {fecha_pico_ati.strftime('%B de %Y')} con un índice de {max_indice_ati:.4f}")

if valid_indices_ama:
    max_indice_ama = max(valid_indices_ama)
    fecha_pico_ama = valid_fechas_ama[valid_indices_ama.index(max_indice_ama)]
    print(f"Pico de floración potencial en Amatitlán: Mes de {fecha_pico_ama.strftime('%B de %Y')} con un índice de {max_indice_ama:.4f}")

"""### **Explicación:** Índice Promedio de Cianobacterias (NDVI) por Mes

$$
\begin{array}{|l|c|c|}
\hline
\textbf{Mes} & \textbf{Índice Promedio - Lago de Atitlán} & \textbf{Índice Promedio - Lago de Amatitlán} \\
\hline
\text{Noviembre 2024} & 0.1822 & 0.2691 \\
\text{Diciembre 2024} & 0.3652 & 0.3277 \\
\text{Enero 2025}     & \textbf{0.4841 (Pico)} & 0.1474 \\
\text{Febrero 2025}   & 0.1871 & 0.1864 \\
\text{Marzo 2025}     & 0.2953 & 0.2415 \\
\text{Abril 2025}     & \text{N/D*}   & \textbf{0.3300 (Pico)} \\
\hline
\end{array}
$$

*El valor para el **Lago de Atitlán en abril de 2025** no pudo ser determinado (N/D), ya que el procesamiento arrojó un resultado inválido. Esto indica que muy probablemente la totalidad del lago estaba cubierta por nubes en las imágenes satelitales disponibles, impidiendo un análisis válido para ese mes.*

<br>

### **Análisis de la Evolución Temporal**

El análisis de la evolución del *Índice de Vegetación de Diferencia Normalizada (NDVI)*, utilizado como un indicador de la concentración de cianobacterias, revela comportamientos distintos y momentos críticos para cada lago durante el período de **noviembre de 2024** a **abril de 2025**. En el **Lago de Atitlán**, se observa un drástico pico de floración en **enero de 2025**, alcanzando un índice promedio de **0.4841**, el valor más alto registrado en todo el análisis para ambos cuerpos de agua. Este pico sugiere un evento de proliferación de algas intenso y concentrado a inicios de año, seguido por una caída abrupta en febrero. Por otro lado, el **Lago de Amatitlán** muestra una dinámica diferente; aunque sus niveles son relativamente altos en diciembre (0.3277), sufren una caída en enero antes de iniciar una recuperación gradual que culmina en su propio pico de floración en **abril de 2025**, con un índice de **0.3300**. Este comportamiento sugiere que, si bien Atitlán experimentó el evento más agudo, la actividad en Amatitlán es más sostenida y tiende a intensificarse hacia el final de la temporada seca, lo cual es consistente con su conocido estado de eutrofización.

### **6.2 Gráficos evolución temporal por lago**
"""

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import numpy as np
from datetime import date

# --- Datos (los mismos para ambos gráficos) ---
fechas = [
    date(2024, 11, 1), date(2024, 12, 1),
    date(2025, 1, 1), date(2025, 2, 1),
    date(2025, 3, 1), date(2025, 4, 1)
]
indices_atitlan = [0.1822, 0.3652, 0.4841, 0.1871, 0.2953, -np.inf]
indices_amatitlan = [0.2691, 0.3277, 0.1474, 0.1864, 0.2415, 0.3300]

# --- Estilo general ---
plt.style.use('seaborn-v0_8-whitegrid')

# ===============================================
#   GRÁFICO 1: LAGO DE ATITLÁN
# ===============================================
fig1, ax1 = plt.subplots(figsize=(14, 7))

# Filtrar y dibujar los datos de Atitlán
valid_fechas_ati = [fechas[i] for i, v in enumerate(indices_atitlan) if np.isfinite(v)]
valid_indices_ati = [v for v in indices_atitlan if np.isfinite(v)]
ax1.plot(valid_fechas_ati, valid_indices_ati,
         marker='o', linestyle='-', markersize=8, color='C0', label='Lago de Atitlán')

# Formato del Gráfico de Atitlán
ax1.set_title('Evolución del Índice de Cianobacterias - Lago de Atitlán', fontsize=18)
ax1.set_xlabel('Fecha', fontsize=14)
ax1.set_ylabel('Índice Promedio (NDVI)', fontsize=14)
ax1.tick_params(axis='both', which='major', labelsize=12)
ax1.set_ylim(bottom=0.1, top=0.5)
ax1.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
ax1.xaxis.set_major_locator(mdates.MonthLocator())
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()


# ===============================================
#   GRÁFICO 2: LAGO DE AMATITLÁN
# ===============================================
fig2, ax2 = plt.subplots(figsize=(14, 7))

# Dibujar los datos de Amatitlán
ax2.plot(fechas, indices_amatitlan,
         marker='s', linestyle='--', markersize=8, color='C1', label='Lago de Amatitlán')

# Formato del Gráfico de Amatitlán
ax2.set_title('Evolución del Índice de Cianobacterias - Lago de Amatitlán', fontsize=18)
ax2.set_xlabel('Fecha', fontsize=14)
ax2.set_ylabel('Índice Promedio (NDVI)', fontsize=14)
ax2.tick_params(axis='both', which='major', labelsize=12)
ax2.set_ylim(bottom=0.1, top=0.5)
ax2.xaxis.set_major_formatter(mdates.DateFormatter('%b %Y'))
ax2.xaxis.set_major_locator(mdates.MonthLocator())
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""**Análisis:** al visualizar la evolución del índice de cianobacterias de forma individual para cada lago, se revelan patrones de comportamiento ecológico marcadamente distintos entre noviembre de 2024 y abril de 2025.
El Lago de Atitlán se caracteriza por una dinámica de alta volatilidad. Muestra un crecimiento explosivo que culmina en un pico de floración de algas extremadamente agudo en enero de 2025, donde el índice NDVI alcanza un valor máximo de 0.48. Este evento sugiere una proliferación intensa pero de corta duración, ya que es seguido por un desplome igualmente drástico en febrero. Este comportamiento de "pico y caída" es indicativo de un sistema que, aunque generalmente más limpio, puede ser susceptible a eventos de floración repentinos y severos bajo condiciones específicas.

Por el contrario, el Lago de Amatitlán exhibe una tendencia más cíclica y sostenida. A diferencia de Atitlán, sufre una caída notable en enero, alcanzando su punto más bajo del período. A partir de ese momento, inicia una recuperación gradual y constante que se extiende durante toda la temporada seca, culminando en un pico de floración en abril de 2025. Este patrón sugiere un proceso de eutrofización más crónico y persistente, donde la biomasa de algas se acumula de manera progresiva a medida que avanzan los meses sin lluvia, en lugar de explotar en un único evento aislado.

### **6.3 Picos de Floración y fechas críticas**
"""

import numpy as np
from datetime import date

fechas = [
    date(2024, 11, 1), date(2024, 12, 1),
    date(2025, 1, 1), date(2025, 2, 1),
    date(2025, 3, 1), date(2025, 4, 1)
]
indices_atitlan = [0.1822, 0.3652, 0.4841, 0.1871, 0.2953, -np.inf]
indices_amatitlan = [0.2691, 0.3277, 0.1474, 0.1864, 0.2415, 0.3300]


# --- Lago de Atitlán ---
valid_indices_ati = [v for v in indices_atitlan if np.isfinite(v)]
if valid_indices_ati:
    max_indice_ati = max(valid_indices_ati)
    indice_pico_ati = indices_atitlan.index(max_indice_ati)
    fecha_pico_ati = fechas[indice_pico_ati]
    print("--- Lago de Atitlán ---")
    print(f"Fecha Crítica: {fecha_pico_ati.strftime('%B de %Y')}")
    print(f"Pico de Floración (NDVI): {max_indice_ati:.4f}\n")


# --- Lago de Amatitlán ---
valid_indices_ama = [v for v in indices_amatitlan if np.isfinite(v)]
if valid_indices_ama:
    max_indice_ama = max(valid_indices_ama)
    indice_pico_ama = indices_amatitlan.index(max_indice_ama)
    fecha_pico_ama = fechas[indice_pico_ama]
    print("--- Lago de Amatitlán ---")
    print(f"Fecha Crítica: {fecha_pico_ama.strftime('%B de %Y')}")
    print(f"Pico de Floración (NDVI): {max_indice_ama:.4f}")

"""### **Análisis de Picos de Floración**
El análisis de los datos permite identificar con claridad los momentos de máxima actividad de cianobacterias para cada lago. Para el Lago de Atitlán, la fecha crítica es, sin duda, enero de 2025. En este mes se registra el pico de floración más significativo de todo el estudio, con un índice NDVI de 0.4841, señalando un evento de proliferación de algas de gran magnitud y de carácter agudo.

En contraste, el Lago de Amatitlán alcanza su punto álgido más tarde, estableciendo su fecha crítica en abril de 2025. Su pico de floración, con un índice de 0.3300, representa la culminación de un incremento gradual durante la temporada seca, lo que demuestra una dinámica de eutrofización más sostenida y predecible en comparación con el evento explosivo de Atitlán.

### **7. Análisis Espacial**

#### **7.1. Mapea la distribución de cianobacteria dentro de cada lago usando matplotlib o folium (genera un mapa interactivo)**

***Descarga GEOTIFF***
"""

# CELDA 1 - Vuelve a descargar el mapa (eligiendo Marzo 2025 para Amatitlán)
import geopandas as gpd
from datetime import date
import calendar
import os

def descargar_mapa_mensual(year, month, geometry, lago_nombre):
    from_date = date(year, month, 1).isoformat()
    last_day = calendar.monthrange(year, month)[1]
    to_date = date(year, month, last_day).isoformat()
    output_filename = f"mapa_{lago_nombre}_{year}_{month:02d}.tif"

    if os.path.exists(output_filename):
        print(f"El archivo {output_filename} ya existe. Saltando descarga.")
        return output_filename

    print(f"Creando trabajo para el mapa de {lago_nombre} de {from_date} a {to_date}...")
    try:
        cube = connection.load_collection(
            "SENTINEL2_L2A",
            spatial_extent=geometry,
            temporal_extent=[from_date, to_date],
            bands=["B03", "B04", "B08", "SCL"]
        )
        scl_band = cube.band("SCL")
        mask = (scl_band == 6)
        cube_masked = cube.mask(mask)
        monthly_avg_cube = cube_masked.reduce_dimension(dimension="t", reducer=lambda data, context: data.mean())
        result_graph = monthly_avg_cube.save_result(format="GTIFF")
        job = connection.create_job(result_graph, title=f"Mapa_{lago_nombre}_{year}-{month}")
        print(f"Trabajo {job.job_id} iniciado. Esperando finalización...")
        job.start_and_wait()
        print(f"Trabajo completado. Descargando mapa a {output_filename}...")
        job.download_results(output_filename)
        return output_filename
    except Exception as e:
        print(f"Error al procesar el trabajo para el mapa de {lago_nombre}: {e}")
        return None

# Mantenemos Enero para Atitlán (ya sabemos que tiene datos)
ruta_mapa_atitlan = descargar_mapa_mensual(2025, 1, lago_atitlan_geom, "atitlan")

# CAMBIO IMPORTANTE: Pedimos Marzo en lugar de Abril para Amatitlán
ruta_mapa_amatitlan = descargar_mapa_mensual(2025, 3, lago_amatitlan_geom, "amatitlan")

print("\nDescarga de mapas completada.")

"""***Generación Mapas Folium***"""

!pip install Pillow
import rasterio
import numpy as np
import folium
from matplotlib import cm
from matplotlib.colors import Normalize
import base64
from io import BytesIO
from PIL import Image
import os
from pyproj import Transformer

def generar_mapa_viridis_filtrable(tif_path, lago_nombre):
    if not tif_path or not os.path.exists(tif_path): return None
    print(f"\n--- Creando mapa 'viridis' con filtros para: {lago_nombre} ---")

    with rasterio.open(tif_path) as src:
        bounds, src_crs = src.bounds, src.crs
        b04_red, b08_nir = src.read(2).astype(float) / 10000.0, src.read(3).astype(float) / 10000.0

    np.seterr(divide='ignore', invalid='ignore'); ndvi = (b08_nir - b04_red) / (b08_nir + b04_red)
    if np.isnan(np.nanmax(ndvi)): return None

    transformer = Transformer.from_crs(src_crs, "EPSG:4326", always_xy=True)
    lon_min, lat_min = transformer.transform(bounds.left, bounds.bottom)
    lon_max, lat_max = transformer.transform(bounds.right, bounds.top)
    wgs84_bounds = [[lat_min, lon_min], [lat_max, lon_max]]

    # Normalización y mapa de color Viridis (se usará para todas las capas)
    norm = Normalize(vmin=-0.2, vmax=0.6)
    colormap = cm.get_cmap('viridis')

    def crear_capa_viridis_filtrada(mask_condicion, name):
        # Crear la imagen completa con el colormap viridis
        viridis_rgba = colormap(norm(ndvi))

        # Hacer transparentes los píxeles que NO cumplen la condición
        # El 4to canal (índice 3) es la transparencia (alpha). 0 = transparente.
        viridis_rgba[~mask_condicion] = 0

        # También hacer transparentes las nubes
        viridis_rgba[np.isnan(ndvi)] = 0

        image = (viridis_rgba * 255).astype(np.uint8)
        pil_img = Image.fromarray(image, 'RGBA')
        img_data = BytesIO(); pil_img.save(img_data, format='PNG')
        img_b64 = base64.b64encode(img_data.getvalue()).decode('utf-8')

        return folium.raster_layers.ImageOverlay(
            image=f'data:image/png;base64,{img_b64}',
            bounds=wgs84_bounds, name=name, show=True)

    mascara_puntos_calientes = ndvi >= 0.2
    mascara_actividad_moderada = (ndvi >= 0.0) & (ndvi < 0.2)
    mascara_agua_clara = ndvi < 0.0
    mascara_nubes = np.isnan(ndvi)

    mapa = folium.Map(tiles="CartoDB positron")

    crear_capa_viridis_filtrada(mascara_puntos_calientes, 'Puntos Calientes (Verde/Amarillo)').add_to(mapa)
    crear_capa_viridis_filtrada(mascara_actividad_moderada, 'Actividad Moderada (Azul claro)').add_to(mapa)
    crear_capa_viridis_filtrada(mascara_agua_clara, 'Agua Clara (Azul oscuro/Violeta)').add_to(mapa)

    # La capa de nubes sigue siendo gris sólido
    nubes_rgba = np.zeros((*ndvi.shape, 4), dtype=np.uint8); nubes_rgba[mascara_nubes] = [128, 128, 128, 180]
    pil_img_nubes = Image.fromarray(nubes_rgba, 'RGBA'); img_data_nubes = BytesIO()
    pil_img_nubes.save(img_data_nubes, format='PNG'); img_b64_nubes = base64.b64encode(img_data_nubes.getvalue()).decode('utf-8')
    folium.raster_layers.ImageOverlay(image=f'data:image/png;base64,{img_b64_nubes}', bounds=wgs84_bounds, name='Zonas sin Datos (Nubes)', show=True).add_to(mapa)

    mapa.fit_bounds(wgs84_bounds)
    folium.LayerControl(collapsed=False).add_to(mapa)
    return mapa

print("--- 7.1: Generando Mapas de Distribución Individuales con Filtros Viridis ---")
mapa_atitlan = generar_mapa_viridis_filtrable('mapa_atitlan_2025_01.tif', 'Lago de Atitlán - Pico (Ene 2025)')
if mapa_atitlan: display(mapa_atitlan)

mapa_amatitlan = generar_mapa_viridis_filtrable('mapa_amatitlan_2025_03.tif', 'Lago de Amatitlán - Pico (Mar 2025)')
if mapa_amatitlan: display(mapa_amatitlan)

"""### **Análisis Espacial de los Mapas de Cianobacterias**

El análisis espacial de los mapas interactivos revela dinámicas ecológicas muy distintas para cada lago en sus meses de mayor actividad. El mapa del **Lago de Amatitlán** para marzo de 2025 muestra una distribución no uniforme de cianobacterias, con claros "puntos calientes" (en color amarillo y verde) concentrados en la cuenca sur, lo que sugiere un impacto directo de la entrada de nutrientes en áreas específicas.

En contraste, el mapa del **Lago de Atitlán** para enero de 2025, si bien muestra la vegetación terrestre circundante con un alto NDVI, presenta una superficie acuática predominantemente de color azul oscuro, indicativo de agua más clara y limpia.

 Esto demuestra que, a pesar de tener un pico promedio elevado en ese mes, la floración fue probablemente muy localizada o el área visible en la imagen se encontraba en buen estado, mostrando una salud superficial visualmente superior a la de Amatitlán. Este análisis visual es crucial, pues confirma que las presiones ambientales no son homogéneas y permite identificar las zonas de mayor vulnerabilidad dentro de cada ecosistema.

### **7.2. Crea mapas comparativos entre diferentes fechas para cada lago.**

***Descarga los mapas de los meses de "baja actividad"***
"""

import geopandas as gpd
from datetime import date
import calendar
import os

def descargar_mapa_mensual(year, month, geometry, lago_nombre):
    from_date = date(year, month, 1).isoformat()
    last_day = calendar.monthrange(year, month)[1]
    to_date = date(year, month, last_day).isoformat()
    output_filename = f"mapa_{lago_nombre}_{year}_{month:02d}.tif"

    if os.path.exists(output_filename):
        print(f"El archivo {output_filename} ya existe. Saltando descarga.")
        return output_filename

    print(f"Creando trabajo para el mapa de {lago_nombre} de {from_date} a {to_date}...")
    try:
        cube = connection.load_collection(
            "SENTINEL2_L2A",
            spatial_extent=geometry,
            temporal_extent=[from_date, to_date],
            bands=["B03", "B04", "B08", "SCL"]
        )
        scl_band = cube.band("SCL")
        mask = (scl_band == 6)
        cube_masked = cube.mask(mask)
        monthly_avg_cube = cube_masked.reduce_dimension(dimension="t", reducer=lambda data, context: data.mean())
        result_graph = monthly_avg_cube.save_result(format="GTIFF")
        job = connection.create_job(result_graph, title=f"Mapa_{lago_nombre}_{year}-{month}")
        print(f"Trabajo {job.job_id} iniciado. Esperando finalización...")
        job.start_and_wait()
        print(f"Trabajo completado. Descargando mapa a {output_filename}...")
        job.download_results(output_filename)
        return output_filename
    except Exception as e:
        print(f"Error al procesar el trabajo para el mapa de {lago_nombre}: {e}")
        return None

# Descargar mes de BAJA actividad para Atitlán (Nov 2024)
descargar_mapa_mensual(2024, 11, lago_atitlan_geom, "atitlan")

# Descargar mes de BAJA actividad para Amatitlán (Ene 2025)
descargar_mapa_mensual(2025, 1, lago_amatitlan_geom, "amatitlan")

print("\nDescarga de mapas adicionales completada.")

"""***Mapa coporativo***"""

import folium
from folium.plugins import DualMap
from pyproj import Transformer
from PIL import Image

def añadir_capas_viridis_filtradas(map_object, tif_path, bounds_to_use):
    if not os.path.exists(tif_path): return
    with rasterio.open(tif_path) as src:
        b04_red, b08_nir = src.read(2).astype(float) / 10000.0, src.read(3).astype(float) / 10000.0

    np.seterr(divide='ignore', invalid='ignore'); ndvi = (b08_nir - b04_red) / (b08_nir + b04_red)
    if np.isnan(np.nanmax(ndvi)): return

    norm = Normalize(vmin=-0.2, vmax=0.6); colormap = cm.get_cmap('viridis')

    def crear_capa_viridis_filtrada(mask_condicion, name):
        viridis_rgba = colormap(norm(ndvi))
        viridis_rgba[~mask_condicion] = 0; viridis_rgba[np.isnan(ndvi)] = 0
        image = (viridis_rgba * 255).astype(np.uint8)
        pil_img = Image.fromarray(image, 'RGBA'); img_data = BytesIO()
        pil_img.save(img_data, format='PNG')
        img_b64 = base64.b64encode(img_data.getvalue()).decode('utf-8')
        return folium.raster_layers.ImageOverlay(image=f'data:image/png;base64,{img_b64}', bounds=bounds_to_use, name=name, show=True)

    mascara_puntos_calientes = ndvi >= 0.2
    mascara_actividad_moderada = (ndvi >= 0.0) & (ndvi < 0.2)
    mascara_agua_clara = ndvi < 0.0

    crear_capa_viridis_filtrada(mascara_puntos_calientes, 'Puntos Calientes').add_to(map_object)
    crear_capa_viridis_filtrada(mascara_actividad_moderada, 'Actividad Moderada').add_to(map_object)
    crear_capa_viridis_filtrada(mascara_agua_clara, 'Agua Clara').add_to(map_object)

def generar_mapa_comparativo_viridis(tif_path1, label1, tif_path2, label2, lat_centro, lon_centro, zoom):
    mapa_dual = DualMap(location=(lat_centro, lon_centro), tiles=None, zoom_start=zoom)
    folium.TileLayer('CartoDB positron').add_to(mapa_dual.m1); folium.TileLayer('CartoDB positron').add_to(mapa_dual.m2)

    with rasterio.open(tif_path1) as src:
        transformer = Transformer.from_crs(src.crs, "EPSG:4326", always_xy=True)
        lon_min, lat_min = transformer.transform(src.bounds.left, src.bounds.bottom)
        lon_max, lat_max = transformer.transform(src.bounds.right, src.bounds.top)
        bounds = [[lat_min, lon_min], [lat_max, lon_max]]

    añadir_capas_viridis_filtradas(mapa_dual.m1, tif_path1, bounds)
    añadir_capas_viridis_filtradas(mapa_dual.m2, tif_path2, bounds)

    folium.Marker([lat_max, lon_min], icon=folium.DivIcon(html=f'<div style="font-family: Arial; font-size: 14px; font-weight: bold; color: black; background-color: white; padding: 5px; border-radius: 5px; border: 1px solid black;">{label1}</div>')).add_to(mapa_dual.m1)
    folium.Marker([lat_max, lon_min], icon=folium.DivIcon(html=f'<div style="font-family: Arial; font-size: 14px; font-weight: bold; color: black; background-color: white; padding: 5px; border-radius: 5px; border: 1px solid black;">{label2}</div>')).add_to(mapa_dual.m2)

    folium.LayerControl(collapsed=False).add_to(mapa_dual.m1); folium.LayerControl(collapsed=False).add_to(mapa_dual.m2)
    return mapa_dual

print("\n--- 7.2: Generando Mapas Comparativos Interactivos con Filtros Viridis ---")
mapa_atitlan = generar_mapa_comparativo_viridis('mapa_atitlan_2024_11.tif', 'Atitlán - Baja (Nov 2024)', 'mapa_atitlan_2025_01.tif', 'Atitlán - Pico (Ene 2025)', 14.67, -91.20, 12)
if mapa_atitlan: display(mapa_atitlan)

mapa_amatitlan = generar_mapa_comparativo_viridis('mapa_amatitlan_2025_01.tif', 'Amatitlán - Baja (Ene 2025)', 'mapa_amatitlan_2025_03.tif', 'Amatitlán - Pico (Mar 2025)', 14.45, -90.57, 13)
if mapa_amatitlan: display(mapa_amatitlan)

"""### **Análisis Comparativo de la Dinámica Espacial**

La comparación visual de los mapas interactivos lado a lado expone de manera contundente la evolución temporal y la naturaleza distinta de la proliferación de cianobacterias en cada lago. Para el **Lago de Amatitlán**, el contraste entre enero (baja actividad) y marzo (pico) de 2025 es drástico: se observa una clara intensificación y expansión de las zonas de alta concentración de algas (en amarillo brillante), confirmando que el florecimiento es un proceso que crece y se agrava a lo largo de la temporada seca, especialmente en la cuenca sur.

En contraste, la comparación del **Lago de Atitlán** revela una historia diferente; el mapa de noviembre de 2024 muestra una superficie predominantemente limpia (azul oscuro), mientras que el mapa del pico de enero de 2025 presenta grandes áreas sin datos (en gris) debido a la alta nubosidad. En las pocas zonas visibles de enero, el agua permanece relativamente limpia. Esto sugiere que, a diferencia del fenómeno expansivo y visible de Amatitlán, el "pico" de Atitlán fue un evento que, o bien estuvo muy localizado y oculto por las nubes, o fue un artefacto estadístico, ya que la evidencia visual disponible no muestra un florecimiento generalizado en toda la superficie del lago.

### **Haga una correlación de los índices (NDVI y NDWI) con la presencia de la cianobacteria. Explique sus hallazgos**

**Atiltlan**
"""

import rasterio
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd
import seaborn as sns

def procesar_datos_lago(tif_path):
    if not os.path.exists(tif_path): return None
    with rasterio.open(tif_path) as src:
        b03_green, b04_red, b08_nir = (src.read(i).astype(float) / 10000.0 for i in (1, 2, 3))
    np.seterr(divide='ignore', invalid='ignore')
    ndvi = (b08_nir - b04_red) / (b08_nir + b04_red)
    ndwi = (b03_green - b08_nir) / (b03_green + b08_nir)
    mascara = ~np.isnan(ndvi) & ~np.isnan(ndwi)
    return pd.DataFrame({'NDVI': ndvi[mascara], 'NDWI': ndwi[mascara]})

def visualizar_correlacion_lago_optimizado(df, lago_nombre):
    if df is None or df.empty:
        print(f"No hay datos para visualizar para {lago_nombre}.")
        return

    df_filtrado = df[(np.abs(df - df.mean()) <= (3 * df.std())).all(axis=1)]

    # --- PASO CLAVE DE OPTIMIZACIÓN: Submuestreo ---
    max_puntos_a_graficar = 50000
    if len(df_filtrado) > max_puntos_a_graficar:
        print(f"El dataset es muy grande ({len(df_filtrado)} puntos). Tomando una muestra de {max_puntos_a_graficar} para graficar...")
        df_grafico = df_filtrado.sample(n=max_puntos_a_graficar, random_state=42)
    else:
        df_grafico = df_filtrado

    # --- Matriz de Correlación (se calcula sobre todos los datos filtrados, es rápido) ---
    plt.figure(figsize=(8, 6))
    sns.heatmap(df_filtrado.corr(), annot=True, cmap='coolwarm', fmt=".3f", vmin=-1, vmax=1)
    plt.title(f'Matriz de Correlación - {lago_nombre}', fontsize=16)
    plt.show()

    # --- Gráfico de Dispersión (se dibuja sobre la muestra, es rápido) ---
    plt.figure(figsize=(10, 7))
    sns.regplot(x='NDWI', y='NDVI', data=df_grafico,
                scatter_kws={'alpha':0.2, 's':10},
                line_kws={'color': 'red', 'linewidth': 3},
                label='Muestra de Píxeles del Lago')
    plt.title(f'Gráfico de Dispersión - {lago_nombre}', fontsize=16)
    plt.xlabel('NDWI (Índice de Agua)', fontsize=12)
    plt.ylabel('NDVI (Índice de Cianobacterias)', fontsize=12)
    plt.legend()
    plt.show()

# --- Ejecutar para Atitlán ---
print("--- Análisis para el Lago de Atitlán (Ene 2025) ---")
df_atitlan = procesar_datos_lago('mapa_atitlan_2025_01.tif')
visualizar_correlacion_lago_optimizado(df_atitlan, 'Lago de Atitlán')

"""### ***Análisis de Correlación y Hallazgos para el Lago de Atitlán***

El análisis cuantitativo de la relación entre los índices espectrales del Lago de Atitlán, realizado sobre los datos del pico de actividad de enero de 2025, revela hallazgos contundentes que validan la metodología de teledetección empleada.

La matriz de correlación de Pearson arroja un coeficiente de **-0.987**, un valor que indica una **correlación negativa casi perfecta** entre el Índice de Vegetación de Diferencia Normalizada (NDVI) y el Índice de Agua de Diferencia Normalizada (NDWI). Esta relación, cercana al valor teórico de -1.0, implica que los dos índices se comportan como indicadores inversamente proporcionales con una altísima fiabilidad: un incremento en uno de ellos se corresponde con una disminución casi idéntica en el otro.

Este resultado numérico encuentra su confirmación visual en el gráfico de dispersión. La nube de puntos, que representa la totalidad de los píxeles de agua sin nubes, se alinea en una diagonal descendente notablemente estrecha y definida. La línea de tendencia de regresión se ajusta con una precisión excepcional sobre esta nube, lo que demuestra la robustez de la relación lineal y la baja variabilidad o "ruido" en los datos. No se observan subgrupos o cúmulos de puntos que se desvíen significativamente de esta tendencia principal.

La interpretación física de esta correlación es fundamental para entender la dinámica del lago:

*   **Dominio del Agua Clara:** En la esquina inferior derecha del gráfico se concentran los píxeles con **NDWI alto** (valores positivos) y **NDVI bajo** (valores negativos). Estos representan el estado predominante del agua del lago: cuerpos de agua claros y profundos donde la señal de agua es fuerte y la biomasa fotosintética en superficie es mínima.

*   **Dominio de la Biomasa:** En el extremo opuesto, en la esquina superior izquierda, los píxeles con **NDVI alto** se corresponden con **NDWI muy bajos o negativos**. Esto ilustra el fenómeno de una floración de algas (bloom): la densa capa de cianobacterias, ricas en clorofila, refleja fuertemente la radiación del infrarrojo cercano (NIR). Esto eleva el NDVI, pero al mismo tiempo "enmascara" la firma espectral del agua, haciendo que el NDWI se desplome.

En conclusión, la correlación tan marcadamente negativa y lineal es característica de un ecosistema acuático profundo y oligotrófico como Atitlán, donde la principal variable que modula la reflectancia de la superficie es la presencia o ausencia de biomasa de fitoplancton. Se valida así el uso del **NDVI como un indicador indirecto (proxy) de alta fiabilidad para la detección y cuantificación de floraciones de cianobacterias**, ya que su comportamiento es un espejo predecible del índice que mide la pureza del agua (NDWI).

**Amatiltlan**
"""

print("\n--- Análisis para el Lago de Amatitlán (Mar 2025) ---")
df_amatitlan = procesar_datos_lago('mapa_amatitlan_2025_03.tif')
visualizar_correlacion_lago(df_amatitlan, 'Lago de Amatitlán')

"""### Análisis de Correlación y Hallazgos para el Lago de Amatitlán

El análisis de correlación para el Lago de Amatitlán, basado en los datos de marzo de 2025, confirma la misma relación fundamental observada en el Lago de Atitlán, aunque con matices importantes que revelan la naturaleza distintiva de este ecosistema.

La matriz de correlación de Pearson muestra un coeficiente de **-0.957**, indicando una **correlación negativa muy fuerte** entre el NDVI y el NDWI. Este valor valida, una vez más, que ambos índices funcionan como indicadores inversos: a mayor biomasa detectada, menor es la firma espectral de agua clara.

Sin embargo, el gráfico de dispersión es donde se aprecian las diferencias clave. A diferencia de la nube de puntos estrecha y definida de Atitlán, el gráfico para Amatitlán muestra una **nube de puntos notablemente más ancha y dispersa**. Aunque la tendencia general descendente es inequívoca y la línea de regresión se ajusta bien, la mayor dispersión de los puntos alrededor de esta línea es significativa.

La interpretación de esta mayor variabilidad es la siguiente:

*   **Heterogeneidad del Agua:** La dispersión indica que el lago no solo presenta los dos estados extremos de "agua muy clara" y "bloom de algas denso". Existe una gama mucho más amplia de **condiciones intermedias**. Estos puntos intermedios pueden representar aguas con diferentes niveles de turbidez por sedimentos, floraciones de algas a distintas profundidades, o una mezcla de materia orgánica disuelta, todo lo cual afecta la reflectancia de manera más compleja.

*   **Indicador de Eutrofización:** Este patrón es el sello distintivo de un **lago eutrófico** como Amatitlán. La constante entrada de nutrientes y sedimentos crea un ecosistema acuático mucho más complejo y heterogéneo en comparación con el sistema oligotrófico de Atitlán. La "nube ancha" es, en efecto, la firma visual de esta complejidad.

En conclusión, si bien la fuerte correlación negativa valida el uso del **NDVI** para monitorear la biomasa en el Lago de Amatitlán, la estructura de su gráfico de dispersión revela una historia más profunda: la de un lago con una alta carga de nutrientes y sedimentos que genera una diversidad de condiciones acuáticas, reflejando su conocido estado de eutrofización.

### **9. Análisis de los lagos y comparación entre ellos:**

#### ***9.1. Haga un análisis de la proliferación de la cianobacteria en el período estudiado para cada uno de los lagos.***
"""

import numpy as np
from datetime import date

#Datos del análisis temporal
fechas = [
    date(2024, 11, 1), date(2024, 12, 1),
    date(2025, 1, 1), date(2025, 2, 1),
    date(2025, 3, 1), date(2025, 4, 1)
]
indices_atitlan = [0.1822, 0.3652, 0.4841, 0.1871, 0.2953, np.nan]
indices_amatitlan = [0.2691, 0.3277, 0.1474, 0.1864, 0.2415, 0.3300]

print("### 9.1. Análisis de Proliferación en el Período Estudiado ###")

# --- Análisis para Atitlán ---
print("\n--- Lago de Atitlán ---")
pico_ati = np.nanmax(indices_atitlan)
fecha_pico_ati = fechas[np.nanargmax(indices_atitlan)]
valle_ati = np.nanmin(indices_atitlan)
fecha_valle_ati = fechas[np.nanargmin(indices_atitlan)]
promedio_ati = np.nanmean(indices_atitlan)

print(f"Pico de Actividad: {pico_ati:.4f} (en {fecha_pico_ati.strftime('%B de %Y')})")
print(f"Punto más bajo: {valle_ati:.4f} (en {fecha_valle_ati.strftime('%B de %Y')})")
print(f"Índice NDVI Promedio del Período: {promedio_ati:.4f}")

# --- Análisis para Amatitlán ---
print("\n--- Lago de Amatitlán ---")
pico_ama = np.max(indices_amatitlan)
fecha_pico_ama = fechas[np.argmax(indices_amatitlan)]
valle_ama = np.min(indices_amatitlan)
fecha_valle_ama = fechas[np.argmin(indices_amatitlan)]
promedio_ama = np.mean(indices_amatitlan)

print(f"Pico de Actividad: {pico_ama:.4f} (en {fecha_pico_ama.strftime('%B de %Y')})")
print(f"Punto más bajo: {valle_ama:.4f} (en {fecha_valle_ama.strftime('%B de %Y')})")
print(f"Índice NDVI Promedio del Período: {promedio_ama:.4f}")

"""### **Análisis:**

### ***9.2. Compara la intensidad y la frecuencia de floraciones entre ambos lagos***
"""

import numpy as np


indices_atitlan = [0.1822, 0.3652, 0.4841, 0.1871, 0.2953, np.nan]
indices_amatitlan = [0.2691, 0.3277, 0.1474, 0.1864, 0.2415, 0.3300]

print("### 9.2. Comparación de Intensidad y Frecuencia ###")

# --- Comparación de Intensidad ---
print("\n--- Intensidad de Floración (Valor Pico de NDVI) ---")
print(f"Lago de Atitlán:   {np.nanmax(indices_atitlan):.4f}")
print(f"Lago de Amatitlán: {np.max(indices_amatitlan):.4f}")

# --- Comparación de Frecuencia ---
UMBRAL_ALERTA_NDVI = 0.25

meses_alerta_ati = sum(1 for indice in indices_atitlan if not np.isnan(indice) and indice > UMBRAL_ALERTA_NDVI)
meses_alerta_ama = sum(1 for indice in indices_amatitlan if indice > UMBRAL_ALERTA_NDVI)
total_meses_validos_ati = sum(1 for indice in indices_atitlan if not np.isnan(indice))

print(f"\n--- Frecuencia de Floración (Meses por encima del umbral de {UMBRAL_ALERTA_NDVI}) ---")
print(f"Lago de Atitlán:   {meses_alerta_ati} de {total_meses_validos_ati} meses estudiados.")
print(f"Lago de Amatitlán: {meses_alerta_ama} de {len(indices_amatitlan)} meses estudiados.")

if meses_alerta_ama > meses_alerta_ati:

    print("\nConclusión: Amatitlán muestra una frecuencia de floración más alta y crónica.")
else:
    print("\nConclusión: Ambos lagos muestran frecuencias similares de floración activa en este período.")

"""### **Análisis:**

### ***9.3. Evalúa posibles diferencias con respecto a las causas de la proliferación de la cianobacteria y discútalas (geografía, uso del suelo, presión urbana, temperatura del agua, del ambiente, clima, etc.).***
"""

import pandas as pd
from IPython.display import display, HTML

print("\n### 9.3. Evaluación Comparativa de Causas de Proliferación ###")

# --- Datos conocidos sobre cada lago para la comparación ---
# Estos datos provienen de estudios limnológicos y geográficos.
data = {
    'Factor Clave': [
        'Estado Trófico General',
        'Presión Urbana Principal',
        'Principal Afluente Contaminante',
        'Profundidad Máxima Aprox.',
        'Volumen de Agua Aprox.',
        'Tipo de Lago',
        'Capacidad de Dilución'
    ],
    'Lago de Atitlán': [
        'Oligotrófico a Mesotrófico',
        'Moderada (Pueblos ribereños)',
        'No tiene un afluente dominante',
        '~ 340 metros',
        '~ 24.0 km³',
        'Endorreico (Caldera Volcánica)',
        'Muy Alta'
    ],
    'Lago de Amatitlán': [
        'Eutrófico a Hipereutrófico',
        'Extrema (Área Metropolitana)',
        'Río Villalobos',
        '~ 25 metros',
        '~ 0.2 km³',
        'Exorreico (Valle)',
        'Muy Baja'
    ]
}

# Crear el DataFrame con los datos
df_comparativo = pd.DataFrame(data)
df_comparativo.set_index('Factor Clave', inplace=True)

# --- Mostrar la tabla comparativa ---
print("Tabla Comparativa de Factores de Influencia:")
display(df_comparativo.style.set_properties(**{'text-align': 'left', 'white-space': 'pre-wrap'}).set_table_styles([dict(selector='th', props=[('text-align', 'left')])]))

# --- Discusión programática basada en la tabla ---
print("\n--- Conclusiones de la Evaluación ---")

# Este es el análisis interpretativo que el código ayuda a generar:
volumen_ati = 24.0
volumen_ama = 0.2
diferencia_volumen = volumen_ati / volumen_ama

print(f"1. Presión de Nutrientes: La principal diferencia es la carga de contaminantes. Amatitlán recibe descargas masivas y constantes del Río Villalobos, mientras que Atitlán no tiene una fuente de contaminación comparable.")
print(f"2. Resiliencia Geográfica: Atitlán es ~{diferencia_volumen:.0f} veces más grande en volumen que Amatitlán. Su inmensa profundidad y volumen le otorgan una capacidad de dilución y resiliencia órdenes de magnitud superior.")
print(f"3. Conclusión Final: El estado crónico de Amatitlán es resultado de una baja resiliencia geográfica sometida a una presión urbana extrema. En contraste, las floraciones de Atitlán son eventos agudos en un sistema mucho más resiliente pero no inmune a la contaminación localizada y estacional.")

"""### **Discusión:**"""